## 图的遍历

* 情景:在n个城市中建设n-1条道路，使得任意两个城市连通，但是要求边权和最小。也就是构建特定的最小生成树。

1. 普利姆算法(Prim)
   * 时间复杂度O(N²)
2. 克鲁斯卡尔算法(Kruskal)：采用贪心思想，按边权值从小到大开始寻找，如果该边的两个端点属于不同的联通分量，则加入该边，否则舍弃该边。
   1. 克鲁斯卡尔需要借助并查集，判断是否在同一个连通分量之中。

### 算法题目

#### PIPI1399最小生成树

![image-20210929102524232](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291025736.png)

* 解法

```cpp
#include<bits/stdc++.h> 
#define inf 99999
using namespace std;
const int N = 101;

struct MGraph{
	int vexnum;//点数 
	int arcs[N][N];//邻接矩阵 
};

struct LGraph{
	int vexnum;//点数 
	vector<int> vertices[N];//邻接表 
};

//普利姆算法 
void Prim(MGraph G){
	int i, n = G.vexnum;//j代表 
	vector<int> d(n);//代表当前集合到剩余点的距离
	vector<int> v(n);//标记访问数组 
	for(i = 1; i < n; ++i) d[i] = G.arcs[0][i];//初始时当前集合，（此时集合只有0）
	v[0] = 1;//避免一个点多次进入当前集合 
	int ans = 0; 
	for(int k = 1; k < n; ++k){
		int j = 0, m = inf;//j代表寻找的边的端点，m代表当前最小花费 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] < m){
				m = d[i];//m会越来越小，直到达到最小值跳出，同时记录最近点和最小距离 
				j = i;//记录距离当前集合距离最小的点 
			}
		}
		ans += m;//选中该边，增加花费
		v[j] = 1;//标记已经访问
		//需要更新当前集合到其他点的最小距离 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] > G.arcs[j][i]){
				d[i] = G.arcs[j][i];
			}
		} 
	} 
	printf("%d", ans);
}
int main(){
	MGraph G;
	int i, j, n;
	scanf("%d", &n);
	G.vexnum = n;
	for(i = 0; i < n; ++i){
		for(j = 0; j < n; ++j){
			scanf("%d", &G.arcs[i][j]);
			if(G.arcs[i][j]==0) G.arcs[i][j] = inf;
		}
	}	
	Prim(G);
	
	return 0;
}
```

#### PIPI1118继续畅通工程

![image-20210929112419644](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291124133.png)

* 解法

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 101;

struct edge{//边结点 
	int x, y;//端点
	int w;//权值
};
int fa[N];//定义并查集
int get(int x){//找父亲 
	if(x==fa[x]) return x;
	return fa[x] = get(fa[x]);
} 
void Kruskal(vector<edge> e, int n){//假设边结点已经排好序 
	for(int i = 1; i <= n; ++i) fa[i] = i;//初始化并查集
	int ans = 0;
	for(int i = 0; i < e.size(); ++i){
		int fx = get(e[i].x);
		int fy = get(e[i].y);
		if(fx != fy){//这两个端点没有连通，需要合并 
			ans += e[i].w;
			fa[fx] = fy;
		}
	} 
	printf("%d\n", ans);
}
int main(void){
	int i, n;
	while(~scanf("%d", &n)) {
		if(n==0) break;
		int m= n*(n-1)/2;//边的数量 
		vector<edge> e(m);
		for(i = 0; i < m; ++i){
			scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].w);
			int p;
			scanf("%d",&p);
			if(p==1) e[i].w = 0;//免费修建 	
		}
		sort(e.begin(), e.end(), [](edge a, edge b)->bool{return a.w<b.w;});
		//考试时只需写sort(e.begin(), e.end());再加个按权值对边结点进行排序
		//或者默认是排好序的 
		Kruskal(e, n);
	}
	
	return 0;
}
```

#### PIPI1099皮皮的油田

* dfs算法

![image-20210929151035061](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291510635.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =101;
bool vis[N][N];
int m, n;
int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {0, 1, -1, 1, -1, 0, 1, -1};
char mp[N][N];//地图
void dfs(int x, int y){//当前访问到x,y点 
	vis[x][y] = 1;
	for(int i = 0; i < 8; ++i){
		int nx = x + dx[i];
		int ny = y + dy[i];
		//得到的新坐标
		if(nx>=0 && nx<m && ny>=0 && ny<n && !vis[nx][ny]  &&  mp[nx][ny] == '@' ) {
			//先判断边界范围
			dfs(nx, ny); //搜索相邻的油田 
		}
	} 
} 
void dfsTraval(){
	int i, j, cnt = 0;
	memset(vis, 0, sizeof(vis));//标记数组初始化不能忘
	for(i = 0; i < m; ++i){
		for(j = 0; j < n; ++j){
			if(!vis[i][j] && mp[i][j]=='@'){
				dfs(i, j);//跳出说明当前连通图遍历完毕 
				cnt++;
			}
		}
	}
	printf("%d\n", cnt);
}

int main(void){
	int i;
	while(~scanf("%d%d", &m, &n)){
		if(n==0&&m==0) break;
		for(i = 0; i < m; ++i){
			scanf("%s", mp[i]);
		}
		dfsTraval();
	
	
	}
	return 0;
}
```

## 图的应用

* 情景：两个地方之间怎么走最短。

1. 迪杰特斯拉(Dijkstra)算法
2. 弗洛伊德(Floyd-Warshall)算法
3. 无权图，可以采用DFS来求解两个点之间的最短路径



