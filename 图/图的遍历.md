## 图的遍历

* 情景:在n个城市中建设n-1条道路，使得任意两个城市连通，但是要求边权和最小。也就是构建特定的最小生成树。

1. 普利姆算法(Prim)
   * 时间复杂度O(N)
2. 克鲁斯卡尔算法(Kruskal)：采用贪心思想，按边权值从小到大开始寻找，如果该边的两个端点属于不同的联通分量，则加入该边，否则舍弃该边。
   1. 克鲁斯卡尔需要借助并查集，判断是否在同一个连通分量之中。

### 算法题目

* PIPI1399

![image-20210929102524232](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291025736.png)

* 解法

```cpp
#include<bits/stdc++.h> 
#define inf 99999
using namespace std;
const int N = 101;

struct MGraph{
	int vexnum;//点数 
	int arcs[N][N];//邻接矩阵 
};

struct LGraph{
	int vexnum;//点数 
	vector<int> vertices[N];//邻接表 
};

//普利姆算法 
void Prim(MGraph G){
	int i, n = G.vexnum;//j代表 
	vector<int> d(n);//代表当前集合到剩余点的距离
	vector<int> v(n);//标记访问数组 
	for(i = 1; i < n; ++i) d[i] = G.arcs[0][i];//初始时当前集合，（此时集合只有0）
	v[0] = 1;//避免一个点多次进入当前集合 
	int ans = 0; 
	for(int k = 1; k < n; ++k){
		int j = 0, m = inf;//j代表寻找的边的端点，m代表当前最小花费 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] < m){
				m = d[i];//m会越来越小，直到达到最小值跳出，同时记录最近点和最小距离 
				j = i;//记录距离当前集合距离最小的点 
			}
		}
		ans += m;//选中该边，增加花费
		v[j] = 1;//标记已经访问
		//需要更新当前集合到其他点的最小距离 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] > G.arcs[j][i]){
				d[i] = G.arcs[j][i];
			}
		} 
	} 
	printf("%d", ans);
}
int main(){
	MGraph G;
	int i, j, n;
	scanf("%d", &n);
	G.vexnum = n;
	for(i = 0; i < n; ++i){
		for(j = 0; j < n; ++j){
			scanf("%d", &G.arcs[i][j]);
			if(G.arcs[i][j]==0) G.arcs[i][j] = inf;
		}
	}	
	Prim(G);
	
	return 0;
}
```

* PIPI1118

![image-20210929112419644](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291124133.png)

* 解法

```cpp


```

