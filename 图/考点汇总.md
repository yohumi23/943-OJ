# 图的遍历

* 深度优先搜索：回溯算法
* 广度优先搜索：类似树的层序遍历，借助队列先进先出的特性层层遍历。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100;
struct MGraph{
	int vexnum;
	int arcs[N][N]; 
}; 

struct LGraph{
	int vexnum;
	vector<int> vertices[N];
};
bool vis[N];

//深度优先搜索DFS
//邻接矩阵 
void dfs(MGraph G, int x){//x是访问的当前结点 
	printf("%d ", x);//处理当前结点，和题目需求有关，
	//如cnt++，去计算访问点数，如果cnt==N，则为连通图 
	vis[x] = 1;
	for(int i = 0; i < G.vexnum; ++i){
		if(G.arcs[x][i] && !vis[i]) dfs(G, i);
	} 
}
//调用dfs
void desTraval(MGraph G){
	memset(vis, 0, sizeof(vis));//对访问数组初始化 
	for(int i = 0; i < G.vexnum; ++i){
		if(!vis[i]) dfs(G, i);//如果没有被访问就对i进行深度优先遍历 ，确保所有的顶点全部遍历到 
	}
} 

//广度优先搜素BFS
//使用邻接矩阵 
void bfs(LGraph G, int x){
	queue<int> q;
	q.push(x);//将第一个点入队
	vis[x] = 1;
	while(!q.empty()) {
		int p = q.front();//取出队首 
		printf("%d ", p);//将当前顶点进行访问操作
		q.pop();//先取出，对其进行结题的操作，之后出队 
		for(int i = 0; i < G.vertices[p].size(); ++i) {
			int y = G.vertices[p][i];
			if(!vis[y]){
				q.push(y);
				vis[i] = 1;//入队时标记为访问，避免重复入队 
			}
		}
	}
}
//BFS调用
void bfsTraval (LGraph G){
	memset(vis, 0, sizeof(vis));//初始化
	for(int i = 0; i < G.vexnum; ++i){
		if(!vis[i]) bfs(G, i);
	}
}
int main(void){

	return 0;
}
```



# 最小生成树问题

* 情景:在n个城市中建设n-1条道路，使得任意两个城市连通，但是要求边权和最小。也就是构建特定的最小生成树。

## 普利姆算法(Prim)

* 时间复杂度O(N²)
* 每次将一个与当前集合距离最近的结点纳入，并重新调整d[i]数组

## 克鲁斯卡尔算法(Kruskal)：

1. 采用贪心思想，按边权值从小到大开始寻找，如果该边的两个端点属于不同的联通分量，则加入该边，否则舍弃该边。
2. 克鲁斯卡尔需要借助并查集，判断是否在同一个连通分量之中。

## 算法题目

### PIPI1399最小生成树(Prim解法)

![image-20210929102524232](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291025736.png)

* 解法

```cpp
#include<bits/stdc++.h> 
#define inf 99999
using namespace std;
const int N = 101;

struct MGraph{
	int vexnum;//点数 
	int arcs[N][N];//邻接矩阵 
};

struct LGraph{
	int vexnum;//点数 
	vector<int> vertices[N];//邻接表 
};

//普利姆算法 
void Prim(MGraph G){
	int i, n = G.vexnum;//j代表 
	vector<int> d(n);//代表当前集合到剩余点的距离
	vector<int> v(n);//标记访问数组 
	for(i = 1; i < n; ++i) d[i] = G.arcs[0][i];//初始时当前集合，（此时集合只有0）
	v[0] = 1;//避免一个点多次进入当前集合 
	int ans = 0; 
	for(int k = 1; k < n; ++k){
		int j = 0, m = inf;//j代表寻找的边的端点，m代表当前最小花费 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] < m){
				m = d[i];//m会越来越小，直到达到最小值跳出，同时记录最近点和最小距离 
				j = i;//记录距离当前集合距离最小的点 
			}
		}
		ans += m;//选中该边，增加花费
		v[j] = 1;//标记已经访问
		//需要更新当前集合到其他点的最小距离 
		for(i = 0; i < n; ++i){
			if(!v[i] && d[i] > G.arcs[j][i]){
				d[i] = G.arcs[j][i];
			}
		} 
	} 
	printf("%d", ans);
}
int main(){
	MGraph G;
	int i, j, n;
	scanf("%d", &n);
	G.vexnum = n;
	for(i = 0; i < n; ++i){
		for(j = 0; j < n; ++j){
			scanf("%d", &G.arcs[i][j]);
			if(G.arcs[i][j]==0) G.arcs[i][j] = inf;
		}
	}	
	Prim(G);
	
	return 0;
}
```

### PIPI1118继续畅通工程(Kruskal解法)

![image-20210929112419644](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291124133.png)

* 解法

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 101;

struct edge{//边结点 
	int x, y;//端点
	int w;//权值
};
int fa[N];//定义并查集
int get(int x){//找父亲 
	if(x==fa[x]) return x;
	return fa[x] = get(fa[x]);
} 
void Kruskal(vector<edge> e, int n){//假设边结点已经排好序 
	for(int i = 1; i <= n; ++i) fa[i] = i;//初始化并查集
	int ans = 0;
	for(int i = 0; i < e.size(); ++i){
		int fx = get(e[i].x);
		int fy = get(e[i].y);
		if(fx != fy){//这两个端点没有连通，需要合并 
			ans += e[i].w;
			fa[fx] = fy;
		}
	} 
	printf("%d\n", ans);
}
int main(void){
	int i, n;
	while(~scanf("%d", &n)) {
		if(n==0) break;
		int m= n*(n-1)/2;//边的数量 
		vector<edge> e(m);
		for(i = 0; i < m; ++i){
			scanf("%d%d%d", &e[i].x, &e[i].y, &e[i].w);
			int p;
			scanf("%d",&p);
			if(p==1) e[i].w = 0;//免费修建 	
		}
		sort(e.begin(), e.end(), [](edge a, edge b)->bool{return a.w<b.w;});
		//考试时只需写sort(e.begin(), e.end());再加个按权值对边结点进行排序
		//或者默认是排好序的 
		Kruskal(e, n);
	}
	
	return 0;
}
```

### PIPI1099皮皮的油田(DFS解法)

* dfs算法

![image-20210929151035061](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109291510635.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =101;
bool vis[N][N];
int m, n;
int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[] = {0, 1, -1, 1, -1, 0, 1, -1};
char mp[N][N];//地图
void dfs(int x, int y){//当前访问到x,y点 
	vis[x][y] = 1;
	for(int i = 0; i < 8; ++i){
		int nx = x + dx[i];
		int ny = y + dy[i];
		//得到的新坐标
		if(nx>=0 && nx<m && ny>=0 && ny<n && !vis[nx][ny]  &&  mp[nx][ny] == '@' ) {
			//先判断边界范围
			dfs(nx, ny); //搜索相邻的油田 
		}
	} 
} 
void dfsTraval(){
	int i, j, cnt = 0;
	memset(vis, 0, sizeof(vis));//标记数组初始化不能忘
	for(i = 0; i < m; ++i){
		for(j = 0; j < n; ++j){
			if(!vis[i][j] && mp[i][j]=='@'){
				dfs(i, j);//跳出说明当前连通图遍历完毕 
				cnt++;
			}
		}
	}
	printf("%d\n", cnt);
}

int main(void){
	int i;
	while(~scanf("%d%d", &m, &n)){
		if(n==0&&m==0) break;
		for(i = 0; i < m; ++i){
			scanf("%s", mp[i]);
		}
		dfsTraval();
	
	
	}
	return 0;
}
```

# 图的应用

## 用dfs算法寻找所有s到t的路径

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 101;
struct MGraph{
	int vexnum;
	int arcs[N][N];
}; 
int vis[N];//标记数组
int path[N], cnt = 0;
//用深度优先搜索寻找到点s到点t的所有路径 
void dfs(MGraph G, int s, int t){
	vis[s] =  1;//当前结点正在被访问
	path[cnt++] = s;//记录当前点
	if(s == t){//已经到达终点 
		for(int i = 0; i < cnt; ++i) printf("%d ", path[i]);//把path中的所有路径结点输出 
		printf("\n");
		vis[s] = 0;//没有这句话，就是只找一条路径
		//回溯
		cnt--;
		return; 
	} 
	for(int i = 0; i < G.vexnum; ++i){//遍历邻接点 
		if(G.arcs[s][i] && !vis[i]) dfs(G, i, t);
	}
	vis[s] = 0;
	cnt--;//回溯 
} 


int main(void){
	int n, m;
	//n个点，m 条边
	MGraph G;
	memset(G.arcs, 0, sizeof(G.arcs));
	scanf("%d %d", &n, &m);
	G.vexnum = n;
	while(m--){//输入m条边 
		int x, y;
		scanf("%d%d", &x, &y);
		G.arcs[x][y] = 1; 
		G.arcs[y][x] = 1; 
	}
	dfs(G, 0, n-1);
	return 0;
}
```

## 解决的问题：两个地方之间怎么走最短。





### **广度优先搜索**求解两个点之间的最短路径（**只适用于完全图**）
#### 1206:PIPI逃亡(BFS求解无权图，第3类问题)

![image-20210930171845251](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109301718670.png)

![image-20210930171917074](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109301719625.png)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 51;
struct MGraph{
	int A, B, C;
	int arcs[N][N][N];
};
struct node{
	int x, y, z;//三维坐标
	int t;//时间 
};
bool vis[N][N][N]; 
int dx[] = {1, -1, 0, 0, 0, 0};
int dy[] = {0, 0, 1, -1, 0, 0};
int dz[] = {0, 0, 0, 0, 1, -1};
//广度优先搜索
int bfs(MGraph G){
	queue<node> q;
	q.push({0, 0, 0, 0});//把起点入队
	memset(vis, 0, sizeof(vis));
	vis[0][0][0] = 1;//标记已访问 
	while(!q.empty()){//bfs搜索 
		node p = q.front();
		q.pop();
		if(p.x == G.A-1 && p.y == G.B-1 && p.z == G.C-1) return p.t;//到达终点
		for(int i=0; i<6; ++i){
			int nx = p.x + dx[i];
			int ny = p.y + dy[i];
			int nz = p.z + dz[i];
			if(nx>=0 && nx<G.A && ny>=0 && ny<G.B && nz>=0 && nz<G.C && G.arcs[nx][ny][nz] == 0 && vis[nx][ny][nz]==0 ){
				q.push({nx, ny, nz, p.t+1});//下一步的时间等于当前时间加1 
				vis[nx][ny][nz] = 1;//标记已经走过 
			}
		}
	} 
	return 9999999;//没有找到，就返回下一个 
} 
int main(void){
	int k;
	scanf("%d", &k);
	while(k--){//k组数据 
		MGraph G;
		int T;
		scanf("%d%d%d%d", &G.A, &G.B, &G.C, &T);
		for(int i=0; i<G.A; ++i){
			for(int j=0; j<G.B; ++j){
				for(int k=0; k<G.C; ++k){
					scanf("%d", &G.arcs[i][j][k]);
				}
			}
		} 
		int time = bfs(G);
		if(time<=T) printf("%d\n", time);
		else printf("-1\n");
		
		
	} 
	return 0;
}
```



### 迪杰特斯拉(Dijkstra)算法
* 用于求解土红某个源点到其他所有点的最短路径。该算法是一种贪心算法，算法思想是每次在剩余未确定最短路径的点中寻找到该源点距离最短的点，每次选择完后要更新每个点到源点的最短距离。
* 贪心：每一步都选择当前情况下的最优路径。

#### 1396: 迪杰斯特拉最短路径算法

![image-20210930215248533](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109302152089.png)

![image-20210930215311225](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202109302153801.png)



### 弗洛伊德(Floyd-Warshall)算法

