# 1. 查找相关概念

![91158F1742C743056FC4324D1EA0292A](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110040919461.png)

* 关于查找长度的定义有歧义：例如哈希表中，最多查找1次，但是没有找到的查找长度是：0，也有说1

# 2. 顺序查找、折半查找和分块查找

## 顺序查找

```cpp
//对升序表进行顺序查找
int SeqSearch(int data[], int n, int key){
    if(n==0 || key < data[0]) return -1;
    if(data[n-1] == key) return n-1;
    for(int i=0; i<n-1; ++i){
        if(key == data[i]) return i;
    }else{
        if(data[i] < key && data[i+1]>key) return -1;
    }
    return -1;//查找元素大于最后一个元素
}
```

## 折半查找（二分查找）

* 仅限有序表 

```cpp
int Binary(int data[], int length, int key){
    int l = 0, r = length - 1, mid;
    while(l<=r){
        mid = (l+r)/2;
        if(key == data[mid]) return mid;
        else if(key>data[mid]) l = mid + 1;
        else r = mid - 1;
    }
}
```

## 分块查找

![image-20211006211409051](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110062114312.png)



* 不怎么考的！！！！





# 3. 哈希表



![C9E953C1E861B8B6F2396A5225838860](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110062117234.png)





![1651C7833FE9A32B4C862B9DCD63B295](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110071519520.png)

# 4. 九大排序

![426CC3A2A77DAD86ECF4CAA0E299CCEF](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110071516287.png)

![7EB85C3FE066E1F0ABBFB8CF379B45FF](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110071522690.png)





## 插入排序

### 直接插入排序

```cpp
//有哨兵A[0]
void InsertSort(int A[], int n){
    int i, j;
    for(i=2; i<=n; ++i){//依次将A[2]~A[n]插入前面已排序序列
        if(A[i]<A[i-1]){
            A[0] = A[i];
            for(j=i-1; A[0]<A[j]; --j) A[j+1] = A[j];
            A[j+1] = A[0];
        }
    }
}

//无哨兵
void InsertSort(int A[], int n){
    int i, j, tmp;
    for(i=1; i<n; ++i){//有区别
        if(A[i]<A[i-1]){
            tmp = A[i];
            for(j=i-1; tmp<A[j] && j>=0; --j){//这里有等号，就是不稳定，没等号，就是稳定
                A[j+1] = A[j];
            }
            A[j+1] = tmp;
        }
    }
}
```

* 时间复杂度： O(N²)
* 空间复杂度： O(1)

## 折半插入排序

```cpp
void InsertSort(int A[], int n){
    int l, r, mid;
    for(int i=2; i<=n; ++i){//i是当前要排序的数
        l = 1;
        r = i-1;
        A[0] = A[i];//暂存
        while(l<=r){
            mid = (l+r)/2;
            if(A[mid]>A[0]){//查找左半子表,这里不用等号，不然会不稳定
                r = mid - 1;
            }
            else l = mid + 1;
        }
        /*for(j=i-1; j>=r+1; --j){
            A[j+1] = A[j];
        }
        A[r+1] = A[0];
        */
        for(int j=i-1; j>=l; --j){
            A[j+1] = A[j]; 
        }
        A[l] = A[0];
    }
}
```

* 时间复杂度： O(N²)

* 空间复杂度： O(1)

* 只是改变了比较的次数

## 希尔排序（缩小增量排序）

![0F58E78FFF89A45C9709FA2230150EC4](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110071631166.png)

```cpp
void ShellSort(ElemType A[], int n){
    //A[0]只是暂存元素，不是哨兵，当j<=0时，插入位置已到
    int dk, i, j;
    for(dk=n/2; dk>=1; dk /= 2){
        for(i=dk+1; i<=n; ++i){
            if(A[i]<A[i-dk]){
            	for(j=i-dk; j>=0 && A[0]<A[j]; j-=dk)
                	A[j+dk] = A[j];
            	A[j+dk] = A[0];                    
            }
        }
    }
}

```



![image-20211007170655027](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110071706610.png)



## 快速排序



