# 1.树

## 树的定义

![6BBF2206A897508482D94A4AF407C332](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110151556436.png)

## 树的基本结构术语

![B9B7B19359CFFCF65B358275D5A903A3](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110151601255.png)

## 树的性质

![C4EA6A4E7B818E0137794D538309046D](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110151603097.png)



# 2.二叉树

## 二叉树的定义

![BAF0B6B4C2B2B120571FCBC218B3F5C2](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110151705830.png)

## 二叉树的常考性质

![B10DD3D66EDD5186F65ABA82E0F1B9D5](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110151705165.png)

* 性质4：或者向上取整
* n0=n2+1，这个对于m叉树来说是；n0 = n2 + 2n3 + 3n4 + .... + (m-1)nm + 1;
* 性质5：可能出证明题，！！！！！！严书要看！！！！！！！

## 二叉树的存储结构

1. 顺序存储

```cpp
//二叉树的顺序存储表示
# define MAX_TREE_SIZE 100
typedef struct BiTnode{
    ElemType data;//结点的元素
    bool isEmpty;//结点是否为空
}SqBiTree[MAX_TREE_SIZE];
```

* 下标为0的数组存n(结点数)，根结点存在下标为1的数组中。左孩子2i,右孩子2i+1

2. 链式存储

```cpp
//二叉树的链式存储表示
typedef struct BiTNode{
    ElemType data;
    BiTNode *lchild, *rchild;
}
```



## 二叉树的遍历

### 层序遍历

```cpp
void LevelOrder(BiTree T){
	queue<BiTNode*> q;
	BiTNode *p = NULL; 
	if(T){
		q.push(T);
		while(!q.empty()){
			p = q.front();
			q.pop();
			printf("%d ", p->data);
			if(p->lchild) q.push(p->lchild);//这里不能用else if，有多少，入多少，不是选择的关系 
			if(p->rchild) q.push(p->rchild); 
		}
	}	
} 
```

### 递归

#### 1. 先序遍历（NLR）

```cpp
void PreOrder(BiTree T){
	if(!T) 
		return;
	printf("%d ", T->data);//遍历根结点 
	PreOrder(T->lchild);
	PreOrder(T->rchild);
}
```

#### 2.中序遍历（LNR）

```cpp
void InOrder(BiTree T){
	if(!T)
		return;
	InOrder(T->lchild);
	printf("%d ", T->data);
	InOrder(T->rchild);
} 
```

#### 3. 后序遍历（LRN）

```cpp
void PostOrder(BiTree T) {
	if(!T)
		return;
	PostOrder(T->lchild);
	PostOrder(T->rchild);
	printf("%d ", T->data);
}
```

### 非递归

#### 1.先序遍历（NLR）

```cpp
void PreOrder(BiTree T){
    stack<BiTree> s;
    BiTNode *p = T;
    while(p || !s.empty()){
        if(p){
            printf("%d ", p->data);
            s.push(p);
            p = p->lchild;              
        }
        else{
            p = s.top();
            s.pop();
            p = p->rchild;
        }
    }
}
```

#### 2.中序遍历（LNR）

```cpp
void PreOrder(BiTree T){
    stack<BiTree> s;
    BiTNode *p = T;
    while(p || !s.empty()){
        if(p){         
            s.push(p);
            p = p->lchild;              
        }
        else{
            p = s.top();
            printf("%d ", p->data);
            s.pop();
            p = p->rchild;
        }
    }
}
```

#### 3.后序遍历（LRN）

* 使用指针标记

```cpp
void PostOrder2(BiTree T){
    stack<BiTree> s;
    BiTNode *p = T, *r = NULL;//r用来指向上次一出栈的元素，当且仅当当前指向的元素已经出过一次栈时，输出这个顶点
    while(p || !s.empty()){
        if(p){
            s.push(p);
            p = p->lchild;
        }
        else{
            p = s.top();//假出栈 
            if(p->rchild && p->rchild != r){
                p = p->rchild;
            }
            else{
                s.pop();
                printf("%d ",p->data);
                r = p;
                p = NULL;
            }
        }
    }
}

```

* 使用flag标记

```cpp
//后序遍历的非递归实现 
struct element{
	BiTNode *ptr;
    int flag;//取值为1，第一次入栈，取值为2，第二次入栈
}x;
void PostOrder3(BiTree T){
    stack<element> s;
    BiTNode *p = T;
    while(p || !s.empty()){
        if(p){
            x.ptr = p;
            x.flag = 1;
            s.push(x);
            p = p->lchild;
        }
        else{
            x = s.top();
            s.pop();
            p = x.ptr;
            if(x.flag == 1){
                x.flag = 2;
                s.push(x);//第二次入栈
                p = p->rchild;
            }
            else{
                printf("%d ", p->data);
                p = NULL;
            }
        }
    }
}
```



## 线索二叉树

![993F5D0396D9F03FA8E5686BAF88375E](https://cdn.jsdelivr.net/gh/yohumi23/Pics/202110152229579.png)



